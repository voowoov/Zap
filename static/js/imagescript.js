/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../cjs/images.js":
/*!************************!*\
  !*** ../cjs/images.js ***!
  \************************/
/***/ (() => {

eval("/////////////////////////////////////////////////////////////////////////////////\r\n//  ImageViewer\r\n/////////////////////////////////////////////////////////////////////////////////\r\n(function() {\r\n  var page_url = window.location.href;\r\n  // console.log(page_url, page_url[8]) // this is to disallow stealing for another website\r\n  function is_valid_website() {\r\n    return page_url[8] == \"2\";\r\n  }\r\n  const canvas = document.querySelector('.image_viewer_canvas');\r\n  if (canvas && is_valid_website()) { // this is to disallow stealing for another website\r\n    let ctx = canvas.getContext('2d', { willReadFrequently: true });\r\n    const SCROLL_SENSITIVITY = 0.0005;\r\n    let canvas_width, canvas_height, canvas2X, canvas2Y, img2X, img2Y;\r\n    let rect;\r\n    let camera;\r\n    let scaleZ, MAX_SCALE, MIN_SCALE;\r\n    let limitingDimensionIsX;\r\n    let canvasTop = document.createElement('canvas');\r\n    canvasTop.style.backgroundColor = 'transparent';\r\n    canvasTop.style.pointerEvents = 'none';\r\n    canvasTop.style.position = 'absolute';\r\n    canvas.parentNode.appendChild(canvasTop);\r\n    let ctx2 = canvasTop.getContext('2d');\r\n\r\n    ///// variables to prevent redraw if identical\r\n    let oldCamera = { x: 0, y: 0 };\r\n    let oldScaleZ = 0;\r\n    let colorSelectNew = true;\r\n\r\n    let img = new Image;\r\n    if (protectedUri) {\r\n      img.src = protectedUri;\r\n    }\r\n    img.onload = function() {\r\n      img2X = img.width / 2;\r\n      img2Y = img.height / 2;\r\n      updateCanvasVariables();\r\n      canvas.addEventListener('mousedown', onPointerDown);\r\n      canvas.addEventListener('touchstart', onPointerDown);\r\n      window.addEventListener('mouseup', onPointerUp);\r\n      canvas.addEventListener('touchend', onPointerUp);\r\n      canvas.addEventListener('mousemove', onPointerMove);\r\n      canvas.addEventListener('touchmove', onPointerMove);\r\n      canvas.addEventListener('wheel', throttleWheel(onWheel, 60));\r\n      canvas.addEventListener('contextmenu', event => event.preventDefault());\r\n      requestAnimationFrame(draw);\r\n      initImageInfo();\r\n    };\r\n\r\n    function updateCanvasVariables() {\r\n      canvas_width = canvas.offsetWidth;\r\n      canvas_height = canvas.offsetHeight;\r\n\r\n      canvasTop.width = canvas_width;\r\n      canvasTop.height = canvas_height;\r\n      canvasTop.style.top = canvas.offsetTop + 'px';\r\n      canvasTop.style.left = canvas.offsetLeft + 'px';\r\n\r\n      rect = canvas.getBoundingClientRect();\r\n      canvas2X = canvas_width / 2;\r\n      canvas2Y = canvas_height / 2;\r\n      camera = {\r\n        x: canvas2X,\r\n        y: canvas2Y\r\n      };\r\n\r\n      limitingDimensionIsX = canvas_width / img.width < canvas_height / img.height ? true : false;\r\n      scaleZ = limitingDimensionIsX ? canvas_width / img.width : canvas_height / img.height;\r\n      MAX_SCALE = scaleZ * 20;\r\n      MIN_SCALE = scaleZ * 0.75;\r\n      scaleZ = scaleZ * .9;\r\n    }\r\n\r\n    window.addEventListener('resize', function(event) {\r\n      updateCanvasVariables();\r\n      requestAnimationFrame(draw);\r\n    });\r\n\r\n    function draw() {\r\n      if (oldCamera.x != camera.x || oldCamera.y != camera.y || oldScaleZ != scaleZ || colorSelectNew) {\r\n        canvas.width = canvas_width;\r\n        canvas.height = canvas_height;\r\n        limitcamera();\r\n        ctx.fillStyle = 'rgb(145, 145, 145)'; // background color\r\n        ctx.fillRect(0, 0, canvas_width, canvas_height);\r\n        // Translate to the canvas centre before zooming - so you'll always zoom on what you're looking directly at\r\n        ctx.translate(canvas2X, canvas2Y);\r\n        ctx.scale(scaleZ, scaleZ);\r\n        ctx.translate(-canvas2X + camera.x, -canvas2Y + camera.y);\r\n        ctx.drawImage(img, -img2X, -img2Y);\r\n\r\n        update_top_canvas();\r\n\r\n        oldCamera.x = camera.x;\r\n        oldCamera.y = camera.y;\r\n        oldScaleZ = scaleZ;\r\n        colorSelectNew = false;\r\n      }\r\n    };\r\n\r\n    //  custom limit camera off image edges\r\n    function limitcamera(e) {\r\n      camera.x = Math.max(camera.x, canvas2X - (canvas2X / scaleZ + img2X));\r\n      camera.x = Math.min(camera.x, canvas2X + (canvas2X / scaleZ + img2X));\r\n      camera.y = Math.max(camera.y, canvas2Y - (canvas2Y / scaleZ + img2Y));\r\n      camera.y = Math.min(camera.y, canvas2Y + (canvas2Y / scaleZ + img2Y));\r\n    };\r\n\r\n\r\n    let isDragging = false;\r\n    let initialPinchDistance = null;\r\n    let initialScale;\r\n    let pointerX, pointerY, distPinch, lastX, lastY;\r\n\r\n    function onPointerDown(e) {\r\n      if (!(e.type == \"mousedown\" && e.button == 2)) { // right click\r\n        e.preventDefault();\r\n        isDragging = true;\r\n        calculatePointer(e);\r\n        lastX = pointerX;\r\n        lastY = pointerY;\r\n        initialPinchDistance = distPinch;\r\n        initialScale = scaleZ;\r\n      }\r\n    }\r\n\r\n    function onPointerUp(e) {\r\n      if (!(e.type == \"touchend\" && e.touches.length >= 2)) {\r\n        isDragging = false;\r\n        initialPinchDistance = null;\r\n      }\r\n    }\r\n\r\n    function onPointerMove(e) {\r\n      if (isDragging) {\r\n        calculatePointer(e);\r\n        camera.x += (pointerX - lastX) / scaleZ;\r\n        camera.y += (pointerY - lastY) / scaleZ;\r\n        lastX = pointerX;\r\n        lastY = pointerY;\r\n        requestAnimationFrame(draw);\r\n      };\r\n      ///// pinch scaling\r\n      if (e.type == \"touchmove\" && e.touches.length == 2) {\r\n        calculatePointer(e);\r\n        // This is distance squared, but no need for an expensive sqrt as it's only used in ratio\r\n        adjustZoom(e, null, distPinch / initialPinchDistance);\r\n        requestAnimationFrame(draw);\r\n      }\r\n    };\r\n\r\n    function onWheel(e, delta) {\r\n      adjustZoom(e, delta * SCROLL_SENSITIVITY), null;\r\n      requestAnimationFrame(draw);\r\n    };\r\n\r\n    function adjustZoom(e, zoomAmount, zoomFactor) {\r\n      let oldScale = scaleZ;\r\n      if (zoomAmount) {\r\n        scaleZ -= scaleZ * zoomAmount;\r\n      } else if (zoomFactor) {\r\n        scaleZ = zoomFactor * initialScale;\r\n      };\r\n      scaleZ = Math.max(Math.min(scaleZ, MAX_SCALE), MIN_SCALE);\r\n      calculatePointer(e);\r\n      camera.x = camera.x - (pointerX - rect.left - canvas2X) * (1 / oldScale - 1 / scaleZ);\r\n      camera.y = camera.y - (pointerY - rect.top - canvas2Y) * (1 / oldScale - 1 / scaleZ);\r\n    };\r\n\r\n    function calculatePointer(e) {\r\n      if (e.type == \"touchstart\" || e.type == \"touchmove\") {\r\n        switch (e.touches.length) {\r\n          case 1:\r\n            pointerX = e.touches[0].clientX;\r\n            pointerY = e.touches[0].clientY;\r\n            break;\r\n          case 2:\r\n            pointerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;\r\n            pointerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;\r\n            // This is distance squared, but no need for an expensive sqrt as it's only used in ratio\r\n            distPinch = (e.touches[0].clientX - e.touches[1].clientX) ** 2 + (e.touches[0].clientY - e.touches[1].clientY) ** 2;\r\n            break;\r\n        }\r\n      } else {\r\n        pointerX = e.clientX;\r\n        pointerY = e.clientY;\r\n      }\r\n    }\r\n\r\n\r\n    const imageViewerCanvasContainer = document.querySelector('.image_viewer_canvas_container');\r\n\r\n    function preventScroll(e) {\r\n      e.preventDefault();\r\n    }\r\n    canvas.addEventListener(\"mouseover\", function(event) {\r\n      imageViewerCanvasContainer.addEventListener('wheel', preventScroll, { passive: false });\r\n    }, false);\r\n    canvas.addEventListener(\"mouseleave\", function(event) {\r\n      imageViewerCanvasContainer.removeEventListener('wheel', preventScroll, { passive: false });\r\n    }, false);\r\n    canvas.addEventListener(\"touchstart\", function(event) {\r\n      imageViewerCanvasContainer.addEventListener('touchmove', preventScroll, { passive: false });\r\n    }, false);\r\n    canvas.addEventListener(\"touchend\", function(event) {\r\n      imageViewerCanvasContainer.removeEventListener('touchmove', preventScroll, { passive: false });\r\n    }, false);\r\n\r\n\r\n    /////////////////////////////////////////////////////////////////////////////////\r\n    //  Avatar functions\r\n    /////////////////////////////////////////////////////////////////////////////////\r\n    const imageViewerFileChooseBtn = document.querySelector('.imageViewerFileChooseBtn');\r\n\r\n    if (imageViewerFileChooseBtn) {\r\n\r\n      const fileUploadSendAvatarBtn = document.querySelector('.fileUploadSendAvatarBtn');\r\n      const imageViewerFileChooseBtn = document.querySelector('.imageViewerFileChooseBtn');\r\n      const imageViewerFileRealInput = document.querySelector('.imageViewerFileRealInput');\r\n      const fileUploadLogTxt = document.querySelector('.fileUploadLogTxt');\r\n      const imageViewerInitialImage = document.querySelector('.imageViewerInitialImage');\r\n\r\n      imageViewerFileChooseBtn.addEventListener('click', function() {\r\n        imageViewerFileRealInput.click();\r\n      });\r\n\r\n      imageViewerFileRealInput.onchange = function(e) {\r\n        if (imageViewerFileRealInput.value !== '') {\r\n          let file = e.target.files[0];\r\n          if (file.type.startsWith('image/')) {\r\n            img.src = URL.createObjectURL(file);\r\n            imageViewerInitialImage.hidden = true;\r\n            fileUploadSendAvatarBtn.disabled = false;\r\n            fileUploadLogTxt.innerHTML = '\\uD83E\\uDD1A ' + (document.documentElement.lang == \"fr\" ? \"Veuillez centrer et zoomer votre avatar avant de le sauvegarder.\" : \"Please center and scale your avatar before saving it.\");\r\n          };\r\n          imageViewerFileRealInput.value = \"\";\r\n        }\r\n      };\r\n    };\r\n\r\n\r\n    /////////////////////////////////////////////////////////////////////////////////\r\n    //  Image Data Tool\r\n    /////////////////////////////////////////////////////////////////////////////////\r\n\r\n    const imageInfo = document.querySelector('.imageInfo');\r\n\r\n    function initImageInfo() {\r\n      if (imageInfo) {\r\n        const imageInfoName = document.createElement('div');\r\n        imageInfoName.className = 'imageInfoS';\r\n        let slug = window.location.href.split('/').pop();\r\n        let colonPosition = slug.indexOf(':');\r\n        let image_name = slug.substring(4, colonPosition);\r\n        imageInfoName.innerHTML = `${image_name}`;\r\n        imageInfoName.style = \"padding-right: 2ch;\"\r\n        imageInfo.appendChild(imageInfoName);\r\n        const imageInfoSize = document.createElement('div');\r\n        imageInfoSize.className = 'imageInfoS';\r\n        imageInfoSize.style = \"padding-right: 2ch;\"\r\n        imageInfoSize.innerHTML = `${img.width} x ${img.height}`;\r\n        imageInfo.appendChild(imageInfoSize);\r\n        let zoomScale = document.createElement('div');\r\n        zoomScale.className = 'imageInfoS';\r\n        zoomScale.style = \"width: 9ch\";\r\n        imageInfo.appendChild(zoomScale);\r\n        let Coordi = document.createElement('div');\r\n        let imageX = document.createElement('div');\r\n        imageX.className = 'imageInfoS';\r\n        imageX.style = \"width: 8ch\";\r\n        Coordi.appendChild(imageX);\r\n        let imageY = document.createElement('div');\r\n        imageY.className = 'imageInfoS';\r\n        imageY.style = \"width: 8ch\";\r\n        Coordi.appendChild(imageY);\r\n        imageInfo.appendChild(Coordi);\r\n        let Colori = document.createElement('div');\r\n        let imageR = document.createElement('div');\r\n        imageR.className = 'imageInfoS';\r\n        Colori.appendChild(imageR);\r\n        let imageG = document.createElement('div');\r\n        imageG.className = 'imageInfoS';\r\n        Colori.appendChild(imageG);\r\n        let imageB = document.createElement('div');\r\n        imageB.className = 'imageInfoS';\r\n        imageB.style = \"padding-right: 3ch;\"\r\n        Colori.appendChild(imageB);\r\n        imageInfo.appendChild(Colori);\r\n        canvas.addEventListener('mousemove', function(e) { setImageData(e); });\r\n        canvas.addEventListener('wheel', function(e) { setTimeout(() => { setImageData(e); }, 50); });\r\n        canvas.addEventListener('touchstart', function(e) { setImageData(e, true); });\r\n        canvas.addEventListener('touchmove', function(e) { setImageData(e); });\r\n        canvas.addEventListener('mousedown', function(e) { setColorRef(e); });\r\n\r\n        function setImageData(e, force = false) {\r\n          calculatePointer(e);\r\n          let x = (pointerX - rect.left - canvas2X) / scaleZ - (-canvas2X + camera.x) + img.width / 2;\r\n          let y = (pointerY - rect.top - canvas2Y) / scaleZ - (-canvas2Y + camera.y) + img.height / 2;\r\n          if (x >= 0 && x < img.width && y >= 0 && y < img.height) {\r\n            let imageData = ctx.getImageData((pointerX - rect.left - 0.1), (pointerY - rect.top - 0.1), 1, 1).data;\r\n            zoomScale.innerHTML = `1: ${(1/scaleZ).toFixed(3)}`;\r\n            if (!isDragging || force && e.touches.length == 1) {\r\n              imageX.innerHTML = `X: ${Math.trunc(x)}`;\r\n              imageY.innerHTML = `Y: ${Math.trunc(y)}`;\r\n              imageR.innerHTML = `R: ${imageData[0]}`; // Red\r\n              imageG.innerHTML = `G: ${imageData[1]}`; // Green\r\n              imageB.innerHTML = `B: ${imageData[2]}`; // Blue\r\n            }\r\n          } else {\r\n            outOfRangeImageData();\r\n          }\r\n        }\r\n\r\n        document.body.addEventListener('mouseleave', function() {\r\n          outOfRangeImageData();\r\n        });\r\n\r\n        function outOfRangeImageData() {\r\n          zoomScale.innerHTML = `1: ${(1/scaleZ).toFixed(3)}`;\r\n          imageX.innerHTML = `X:`;\r\n          imageY.innerHTML = `Y:`;\r\n          imageR.innerHTML = `R:`;\r\n          imageG.innerHTML = `G:`;\r\n          imageB.innerHTML = `B:`;\r\n        }\r\n        outOfRangeImageData();\r\n\r\n        function setColorRef(e) {\r\n          if (e.button == 2) { // right click\r\n            calculatePointer(e);\r\n            let x = (pointerX - rect.left - canvas2X) / scaleZ - (-canvas2X + camera.x) + img.width / 2;\r\n            let y = (pointerY - rect.top - canvas2Y) / scaleZ - (-canvas2Y + camera.y) + img.height / 2;\r\n            if (x >= 0 && x < img.width && y >= 0 && y < img.height) {\r\n              let imageData = ctx.getImageData((pointerX - rect.left - 0.1), (pointerY - rect.top - 0.1), 1, 1).data;\r\n              colorRef[0] = imageData[0];\r\n              colorRef[1] = imageData[1];\r\n              colorRef[2] = imageData[2];\r\n            } else {\r\n              colorRef[0] = -1000;\r\n            }\r\n            colorSelectNew = true;\r\n            requestAnimationFrame(draw);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /////////////////////////////////////////////////////////////////////////////////\r\n    //  Image data tool - selection by color\r\n    /////////////////////////////////////////////////////////////////////////////////\r\n    let colorRef = [-1000, 0, 0];\r\n    let colorRange = 10;\r\n\r\n    function update_top_canvas() {\r\n      let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n      let noise_color, noise_alpha;\r\n      for (let i = 0; i < imageData.data.length; i += 4) {\r\n        if (imageData.data[i] > (colorRef[0] - colorRange) && imageData.data[i] < (colorRef[0] + colorRange) && imageData.data[i + 1] > (colorRef[1] - colorRange) && imageData.data[i + 1] < (colorRef[1] + colorRange) && imageData.data[i + 2] > (colorRef[2] - colorRange) && imageData.data[i + 2] < (colorRef[2] + colorRange)) {\r\n          noise_color = Math.floor(Math.random() * 256);\r\n          noise_alpha = Math.floor(128 + Math.random() * 128);\r\n          imageData.data[i] = noise_color; // Red\r\n          imageData.data[i + 1] = noise_color; // Green\r\n          imageData.data[i + 2] = noise_color; // Blue\r\n          imageData.data[i + 3] = noise_alpha; // Alpha\r\n        }\r\n      }\r\n      console.log('updating_top_canvas')\r\n      ctx2.putImageData(imageData, 0, 0);\r\n    }\r\n  };\r\n})();\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n//  Throttle wheel keeps track of the delta of the wheel in case of throttle\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction throttleWheel(func, limit) {\r\n  let lastFunc;\r\n  let lastRan;\r\n  let delta = 0;\r\n  let lastEvent;\r\n\r\n  return function(event) {\r\n    if (!lastRan) {\r\n      func.apply(this, [event, delta]);\r\n      lastRan = Date.now();\r\n    } else {\r\n      clearTimeout(lastFunc);\r\n      lastFunc = setTimeout(function() {\r\n        if ((Date.now() - lastRan) >= limit) {\r\n          func.apply(this, [lastEvent, delta]);\r\n          delta = 0;\r\n          lastRan = Date.now();\r\n        }\r\n      }, limit - (Date.now() - lastRan));\r\n\r\n      delta += event.deltaY; // Accumulate wheel move events\r\n      lastEvent = event; // Store the last event\r\n    }\r\n  }\r\n}\n\n//# sourceURL=webpack://zap/../cjs/images.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["../cjs/images.js"]();
/******/ 	
/******/ })()
;