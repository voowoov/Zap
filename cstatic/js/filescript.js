/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../cjs/filespro.js":
/*!**************************!*\
  !*** ../cjs/filespro.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wsiToFilesproAskForListOfFiles: () => (/* binding */ wsiToFilesproAskForListOfFiles),\n/* harmony export */   wsiToFilesproMessageReceived: () => (/* binding */ wsiToFilesproMessageReceived)\n/* harmony export */ });\n/* harmony import */ var _wsi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wsi.js */ \"../cjs/wsi.js\");\n\r\n\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n//  File uploads\r\n/////////////////////////////////////////////////////////////////////////////////\r\nconst pageLanguage = document.documentElement.lang;\r\n\r\nconst fileChunkSize = 1990; // Size of chunks\r\nconst fileMaxNbChunks = 100;\r\nconst fileMaxSize = 10000000;\r\n\r\nconst filePartialSize = fileChunkSize * fileMaxNbChunks; // Size of chunks\r\nlet filePortionStep = 0;\r\nlet filePortionsArray = [];\r\nlet fileUploadName;\r\n\r\nconst fileUploadListTxt = document.getElementById('fileUploadListTxt')\r\nconst fileUploadRealInput = document.getElementById('fileUploadRealInput');\r\nconst fileUploadChooseBtn = document.getElementById('fileUploadChooseBtn');\r\nconst fileUploadChoiceTxt = document.getElementById('fileUploadChoiceTxt');\r\nconst fileUploadSendBtn = document.getElementById('fileUploadSendBtn');\r\nconst fileUploadCancelBtn = document.getElementById('fileUploadCancelBtn');\r\nconst fileUploadLogTxt = document.getElementById('fileUploadLogTxt')\r\n\r\nfunction wsiToFilesproAskForListOfFiles() {\r\n  ;(0,_wsi_js__WEBPACK_IMPORTED_MODULE_0__.wsiSend)('f' + _wsi_js__WEBPACK_IMPORTED_MODULE_0__.wsiCurrentTabId + \"u\");\r\n}\r\nfunction wsiToFilesproMessageReceived(message) {\r\n\r\n  switch (message[0]) {\r\n    case 'u':\r\n      updateListOfFilesFromData(message.substring(1));\r\n      break;\r\n    case 'a':\r\n      sendFilePartialUpload();\r\n      break;\r\n    case 'r':\r\n      receivedConfirmationUpload();\r\n      break;\r\n    case 'e':\r\n      errorFileUpload(message.substring(1));\r\n      break;\r\n  }\r\n}\r\n\r\n\r\nfileUploadChooseBtn.addEventListener('click', function() {\r\n  fileUploadRealInput.click();\r\n});\r\nfileUploadRealInput.addEventListener('change', function() {\r\n  updateFileUploadChoiceTxt()\r\n});\r\n\r\nfunction updateFileUploadChoiceTxt() {\r\n  if (fileUploadRealInput.value) {\r\n    let fileName = fileUploadRealInput.value.split('\\\\').pop();\r\n    if (is_valid_filename(fileName)) {\r\n      fileUploadChoiceTxt.innerHTML = fileName;\r\n      fileUploadSendBtn.disabled = false;\r\n      fileUploadCancelBtn.disabled = false;\r\n      if (pageLanguage == \"fr\") {\r\n        fileUploadLogTxt.innerHTML = '\\uD83D\\uDCC4' + \" Fichier sélectionné. \";\r\n      } else {\r\n        fileUploadLogTxt.innerHTML = '\\uD83D\\uDCC4' + \" File selected. \";\r\n      }\r\n    } else {\r\n      if (pageLanguage == \"fr\") {\r\n        fileUploadLogTxt.innerHTML = '\\u26A0' + ' Nom de fichier invalide.';\r\n      } else {\r\n        fileUploadLogTxt.innerHTML = '\\u26A0' + ' Invalid file name.';\r\n      }\r\n    }\r\n  } else {\r\n    if (pageLanguage == \"fr\") {\r\n      fileUploadChoiceTxt.innerHTML = 'Pas de fichier choisi.';\r\n    } else {\r\n      fileUploadChoiceTxt.innerHTML = 'No file chosen, yet.';\r\n    }\r\n  }\r\n}\r\n\r\nfunction errorFileUpload(strError) {\r\n  switch (strError) {\r\n    case 'file already exists':\r\n      if (pageLanguage == \"fr\") {\r\n        fileUploadLogTxt.innerHTML = '\\u26A0' + ' Le fichier est déjà partagé. ';\r\n      } else {\r\n        fileUploadLogTxt.innerHTML = '\\u26A0' + ' The file is already shared. ';\r\n      }\r\n      break;\r\n    default:\r\n      if (pageLanguage == \"fr\") {\r\n        fileUploadLogTxt.innerHTML = 'Erreur en envoyant le fichier.';\r\n      } else {\r\n        fileUploadLogTxt.innerHTML = 'Error while sending file.';\r\n      }\r\n  }\r\n  fileUploadChooseBtn.disabled = false;\r\n  fileUploadSendBtn.disabled = false;\r\n  filePortionStep = 0;\r\n  filePortionsArray = [];\r\n}\r\n\r\nfunction clearSelectionFileUpload() {\r\n  fileUploadRealInput.value = \"\"\r\n  updateFileUploadChoiceTxt()\r\n  fileUploadChooseBtn.disabled = false;\r\n  fileUploadSendBtn.disabled = true;\r\n  fileUploadCancelBtn.disabled = true;\r\n  filePortionStep = 0;\r\n  filePortionsArray = [];\r\n}\r\n\r\nfileUploadCancelBtn.addEventListener('click', throttle(function() {\r\n\r\n  if (filePortionsArray.length > 0) {\r\n    if (pageLanguage == \"fr\") {\r\n      fileUploadLogTxt.innerHTML = '\\u2716' + \" Envoie du fichier cancellé. \";\r\n    } else {\r\n      fileUploadLogTxt.innerHTML = '\\u2716' + \" Sending file was canceled. \";\r\n    }\r\n    fileUploadChooseBtn.disabled = false;\r\n    fileUploadSendBtn.disabled = false;\r\n    fileUploadCancelBtn.disabled = false;\r\n    filePortionStep = 0;\r\n    filePortionsArray = [];\r\n    (0,_wsi_js__WEBPACK_IMPORTED_MODULE_0__.wsiSend)('f' + _wsi_js__WEBPACK_IMPORTED_MODULE_0__.wsiCurrentTabId + \"c\");\r\n  } else {\r\n    fileUploadLogTxt.innerHTML = \"\"\r\n    clearSelectionFileUpload()\r\n  }\r\n}, 2000));\r\n\r\nfileUploadSendBtn.addEventListener('click', function() {\r\n  var x = fileUploadRealInput;\r\n  if ('files' in x) {\r\n    if (x.files.length == 1) {\r\n      var file = x.files[0];\r\n      if (is_valid_filename(file.name)) {\r\n        if (file.size < fileMaxSize) {\r\n          fileUploadChooseBtn.disabled = true;\r\n          fileUploadSendBtn.disabled = true;\r\n          fileUploadName = file.name\r\n          filePortionStep = 0\r\n          filePortionsArray = dividePortionsArray(file.size, filePartialSize);\r\n          (0,_wsi_js__WEBPACK_IMPORTED_MODULE_0__.wsiSend)('f' + _wsi_js__WEBPACK_IMPORTED_MODULE_0__.wsiCurrentTabId + 's' + JSON.stringify({ file_name: file.name, file_size: file.size }));\r\n        } else {\r\n          alert(\"The file is too large.\")\r\n        }\r\n      } else {\r\n        alert(\"Invalid file name.\")\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\nfunction sendFilePartialUpload() {\r\n  try {\r\n    const file = fileUploadRealInput.files[0]; // Get file from file input\r\n    var chunksNb = Math.ceil(filePortionsArray[filePortionStep][2] / fileChunkSize); // Number of chunks\r\n    var chunkId = 0; // Start with the first chunk\r\n    var percentage = Math.floor(filePortionStep / filePortionsArray.length * 100).toString() + ' %';\r\n    if (pageLanguage == \"fr\") {\r\n      fileUploadLogTxt.innerHTML = '\\u231B' + \" Envoie du fichier en cours.  \" + percentage;\r\n    } else {\r\n      fileUploadLogTxt.innerHTML = '\\u231B' + \" Sending file in progress.  \" + percentage;\r\n    }\r\n\r\n    function readNextChunk() {\r\n      return new Promise((resolve, reject) => {\r\n        if (chunkId < chunksNb) {\r\n          var start = filePortionsArray[filePortionStep][0] + chunkId * fileChunkSize;\r\n          var end = Math.min(start + fileChunkSize, filePortionsArray[filePortionStep][1] + 1);\r\n          var blob = file.slice(start, end); // Create a blob representing the chunk\r\n          var reader = new FileReader();\r\n          reader.onloadend = function(evt) {\r\n            if (evt.target.readyState == FileReader.DONE) { // When the chunk is read\r\n              // make the byte array with [Chunk id (4 bytes int) + File byte array (rest of the bytes)]\r\n              var buffer = new ArrayBuffer(4),\r\n                view = new DataView(buffer);\r\n              view.setInt32(0, chunkId, true);\r\n              var resultByteLength = evt.target.result.byteLength,\r\n                arrayBuffer = new Uint8Array(view.byteLength + resultByteLength);\r\n              arrayBuffer.set(new Uint8Array(view.buffer));\r\n              arrayBuffer.set(new Uint8Array(evt.target.result), view.byteLength);\r\n              (0,_wsi_js__WEBPACK_IMPORTED_MODULE_0__.wsiSend)(arrayBuffer);\r\n              chunkId++;\r\n              resolve(readNextChunk()); // Resolve the promise with the next recursive call\r\n            }\r\n          };\r\n          reader.readAsArrayBuffer(blob);\r\n        } else {\r\n          resolve(); // Resolve the promise when there are no more chunks to read\r\n        }\r\n      });\r\n    }\r\n    readNextChunk().then(() => {\r\n      filePortionStep++;\r\n    });\r\n  } catch (error) {\r\n    // console.error(error);\r\n  }\r\n}\r\n\r\nfunction receivedConfirmationUpload() {\r\n  if (pageLanguage == \"fr\") {\r\n    fileUploadLogTxt.innerHTML = '\\u2713' + \" Envoie réeussi de \" + fileUploadName;\r\n  } else {\r\n    fileUploadLogTxt.innerHTML = '\\u2713' + \" Sent successfully \" + fileUploadName;\r\n  }\r\n  clearSelectionFileUpload()\r\n}\r\n\r\nfunction is_valid_filename(filename) {\r\n  // Check if filename starts with alphanumeric or underscore, followed by alphanumeric, underscore, hyphen, and contains only one dot\r\n  // Check if extension is alphanumeric\r\n  let filenameRegex = /^\\w[\\w\\s-]*\\S\\.\\w+$/;\r\n  if (!filenameRegex.test(filename)) {\r\n    return false;\r\n  }\r\n  if (filename.length > 50) {\r\n    return false;\r\n  }\r\n  // Check if extension is present and not too long\r\n  let extension = filename.split('.').pop();\r\n  if (!extension || extension.length < 3 || extension.length > 5) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n// sets a 2d Array with start position, end position and length for each portion of the file\r\n// ex 10 and 3 will output  [[0, 2, 3], [3, 5, 3], [6, 8, 3], [9, 9, 1]]\r\nfunction dividePortionsArray(fullSize, partialSize) {\r\n  var quotient = Math.floor(fullSize / partialSize);\r\n  var remainder = fullSize % partialSize;\r\n  var start = 0;\r\n  var portions = [];\r\n  for (var i = 0; i < quotient; i++) {\r\n    var end = start + partialSize;\r\n    portions.push([start, end - 1, partialSize]);\r\n    start = end;\r\n  }\r\n  if (remainder != 0) {\r\n    portions.push([start, start + remainder - 1, remainder]);\r\n  }\r\n  return portions;\r\n}\r\n\r\nfunction updateListOfFilesFromData(data) {\r\n  let fileMetaList = JSON.parse(data);\r\n\r\n  let ulItems = fileMetaList.map(fileMeta => {\r\n    return `<li>${fileMeta.file_name}</li>`;\r\n  });\r\n\r\n  let ulString = `<ul>${ulItems.join('')}</ul>`;\r\n  fileUploadListTxt.innerHTML = ulString\r\n};\r\n\r\nfunction throttle(func, delay) {\r\n  let lastCall = 0;\r\n\r\n  return function(...args) {\r\n    const now = Date.now();\r\n\r\n    if (now - lastCall < delay) {\r\n      return;\r\n    }\r\n\r\n    lastCall = now;\r\n    return func.apply(this, args);\r\n  };\r\n}\r\n\r\nsetTimeout(function() {\r\n  (0,_wsi_js__WEBPACK_IMPORTED_MODULE_0__.wsiOpenSharedSocket)();\r\n}, 0);\n\n//# sourceURL=webpack://zap/../cjs/filespro.js?");

/***/ }),

/***/ "../cjs/images.js":
/*!************************!*\
  !*** ../cjs/images.js ***!
  \************************/
/***/ (() => {

eval("const canvas = document.getElementById(\"image_viewer_canvas\")\r\nlet ctx = canvas.getContext('2d')\r\nconst SCROLL_SENSITIVITY = 0.0005\r\nlet canvas_width, canvas_height, canvas2X, canvas2Y, img2X, img2Y;\r\nlet camera\r\nlet scaleZ, MAX_SCALE, MIN_SCALE\r\nlet limitingDimensionIsX\r\n\r\nvar img = new Image;\r\nif (protectedUri) {\r\n  img.src = protectedUri;\r\n}\r\nimg.onload = function() {\r\n  img2X = img.width / 2;\r\n  img2Y = img.height / 2;\r\n\r\n  // wait a bit for the canvas\r\n  setTimeout(function() {\r\n    updateCanvasVariables();\r\n    canvas.addEventListener('mousedown', onPointerDown)\r\n    canvas.addEventListener('touchstart', (e) => handleTouch(e, onPointerDown))\r\n    window.addEventListener('mouseup', onPointerUp)\r\n    canvas.addEventListener('touchend', (e) => handleTouch(e, onPointerUp))\r\n    canvas.addEventListener('mousemove', onPointerMove)\r\n    canvas.addEventListener('touchmove', (e) => handleTouch(e, onPointerMove))\r\n    canvas.addEventListener('wheel', (e) => adjustZoom(e.deltaY * SCROLL_SENSITIVITY))\r\n    draw()\r\n  }, 0); // Delay in milliseconds \r\n}\r\n\r\nfunction updateCanvasVariables() {\r\n  canvas_width = canvas.offsetWidth;\r\n  canvas_height = canvas.offsetHeight;\r\n  canvas2X = canvas_width / 2\r\n  canvas2Y = canvas_height / 2\r\n  camera = {\r\n    x: canvas2X,\r\n    y: canvas2Y\r\n  }\r\n  limitingDimensionIsX = canvas_width / img.width < canvas_height / img.height ? true : false;\r\n  scaleZ = limitingDimensionIsX ? canvas_width / img.width : canvas_height / img.height;\r\n  MAX_SCALE = scaleZ * 20\r\n  MIN_SCALE = scaleZ\r\n    // Fill the canvas with the red color\r\n\r\n}\r\n\r\nwindow.addEventListener('resize', function(event) {\r\n  updateCanvasVariables()\r\n});\r\n\r\nfunction draw() {\r\n  canvas.width = canvas_width\r\n  canvas.height = canvas_height\r\n  limitcamera()\r\n  ctx.fillStyle = 'rgb(145, 145, 145)'; // background color\r\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n  // Translate to the canvas centre before zooming - so you'll always zoom on what you're looking directly at\r\n  ctx.translate(canvas2X, canvas2Y)\r\n  ctx.scale(scaleZ, scaleZ)\r\n  ctx.translate(-canvas2X + camera.x, -canvas2Y + camera.y)\r\n  ctx.drawImage(img, -img2X, -img2Y);\r\n  setTimeout(function() {\r\n    requestAnimationFrame(draw);\r\n  }, 50); // Delay in milliseconds\r\n}\r\n\r\n//  custom limit camera off image edges\r\nfunction limitcamera(e) {\r\n  if (!limitingDimensionIsX && img.width * scaleZ < canvas.width) {\r\n    camera.x = Math.min(camera.x, canvas2X + (canvas2X / scaleZ - img2X))\r\n    camera.x = Math.max(camera.x, canvas2X - (canvas2X / scaleZ - img2X))\r\n    camera.y = Math.min(camera.y, canvas2Y - (canvas2Y / scaleZ - img2Y))\r\n    camera.y = Math.max(camera.y, canvas2Y + (canvas2Y / scaleZ - img2Y))\r\n  } else if (limitingDimensionIsX && img.height * scaleZ < canvas.height) {\r\n    camera.x = Math.min(camera.x, canvas2X - (canvas2X / scaleZ - img2X))\r\n    camera.x = Math.max(camera.x, canvas2X + (canvas2X / scaleZ - img2X))\r\n    camera.y = Math.min(camera.y, canvas2Y + (canvas2Y / scaleZ - img2Y))\r\n    camera.y = Math.max(camera.y, canvas2Y - (canvas2Y / scaleZ - img2Y))\r\n  } else {\r\n    camera.x = Math.min(camera.x, canvas2X - (canvas2X / scaleZ - img2X))\r\n    camera.x = Math.max(camera.x, canvas2X + (canvas2X / scaleZ - img2X))\r\n    camera.y = Math.min(camera.y, canvas2Y - (canvas2Y / scaleZ - img2Y))\r\n    camera.y = Math.max(camera.y, canvas2Y + (canvas2Y / scaleZ - img2Y))\r\n  }\r\n}\r\n\r\n// Gets the relevant location from a mouse or single touch event\r\nfunction getEventLocation(e) {\r\n  if (e.touches && e.touches.length == 1) {\r\n    return {\r\n      x: e.touches[0].clientX,\r\n      y: e.touches[0].clientY\r\n    }\r\n  } else if (e.clientX && e.clientY) {\r\n    return {\r\n      x: e.clientX,\r\n      y: e.clientY\r\n    }\r\n  }\r\n}\r\n\r\nlet isDragging = false\r\nlet dragStart = {\r\n  x: 0,\r\n  y: 0\r\n}\r\n\r\nfunction onPointerDown(e) {\r\n  isDragging = true\r\n  dragStart.x = getEventLocation(e).x / scaleZ - camera.x\r\n  dragStart.y = getEventLocation(e).y / scaleZ - camera.y\r\n}\r\n\r\nfunction onPointerUp(e) {\r\n  isDragging = false\r\n  initialPinchDistance = null\r\n  lastZoom = scaleZ\r\n}\r\n\r\nfunction onPointerMove(e) {\r\n  if (isDragging) {\r\n    camera.x = getEventLocation(e).x / scaleZ - dragStart.x\r\n    camera.y = getEventLocation(e).y / scaleZ - dragStart.y\r\n  }\r\n}\r\n\r\nfunction handleTouch(e, singleTouchHandler) {\r\n  if (e.touches.length <= 1) // 1 fingers or 0 at touchend\r\n  {\r\n    singleTouchHandler(e)\r\n  } else if (e.type == \"touchmove\" && e.touches.length == 2) {\r\n    isDragging = false\r\n    handlePinch(e)\r\n  }\r\n}\r\n\r\nlet initialPinchDistance = null\r\nlet lastZoom = scaleZ\r\n\r\nfunction handlePinch(e) {\r\n  e.preventDefault()\r\n\r\n  let touch1 = {\r\n    x: e.touches[0].clientX,\r\n    y: e.touches[0].clientY\r\n  }\r\n  let touch2 = {\r\n    x: e.touches[1].clientX,\r\n    y: e.touches[1].clientY\r\n  }\r\n\r\n  // This is distance squared, but no need for an expensive sqrt as it's only used in ratio\r\n  let currentDistance = (touch1.x - touch2.x) ** 2 + (touch1.y - touch2.y) ** 2\r\n\r\n  if (initialPinchDistance == null) {\r\n    initialPinchDistance = currentDistance\r\n  } else {\r\n    adjustZoom(null, currentDistance / initialPinchDistance)\r\n  }\r\n}\r\n\r\nfunction adjustZoom(zoomAmount, zoomFactor) {\r\n  if (!isDragging) {\r\n    if (zoomAmount) {\r\n      scaleZ -= scaleZ * zoomAmount\r\n      lastZoom = scaleZ\r\n    } else if (zoomFactor) {\r\n      scaleZ = zoomFactor * lastZoom\r\n    }\r\n\r\n    scaleZ = Math.min(scaleZ, MAX_SCALE)\r\n    scaleZ = Math.max(scaleZ, MIN_SCALE)\r\n\r\n  }\r\n}\r\n\r\nconst imageViewerCanvasContainer = document.getElementById(\"image_viewer_canvas_container\");\r\n\r\nfunction preventScroll(e) {\r\n  e.preventDefault();\r\n}\r\ncanvas.addEventListener(\"mouseover\", function(event) {\r\n  imageViewerCanvasContainer.addEventListener('wheel', preventScroll, { passive: false });\r\n}, false);\r\ncanvas.addEventListener(\"mouseleave\", function(event) {\r\n  imageViewerCanvasContainer.removeEventListener('wheel', preventScroll, { passive: false });\r\n}, false);\r\ncanvas.addEventListener(\"touchstart\", function(event) {\r\n  imageViewerCanvasContainer.addEventListener('touchmove', preventScroll, { passive: false });\r\n}, false);\r\ncanvas.addEventListener(\"touchend\", function(event) {\r\n  imageViewerCanvasContainer.removeEventListener('touchmove', preventScroll, { passive: false });\r\n}, false);\r\n\r\nconst imageViewerFileRealInput = document.getElementById('imageViewerFileRealInput');\r\nconst imageViewerFileChooseBtn = document.getElementById('imageViewerFileChooseBtn');\r\nconst imageViewerFileChoiceTxt = document.getElementById('imageViewerFileChoiceTxt');\r\nconst imageViewerFileSaveBtn = document.getElementById('imageViewerFileSaveBtn');\r\nconst imageViewerInitialImage = document.getElementById('image_viewer_initial_image');\r\n\r\nimageViewerFileChooseBtn.addEventListener('click', function() {\r\n  imageViewerFileRealInput.click();\r\n});\r\n\r\nimageViewerFileRealInput.onchange = function(e) {\r\n  let file = e.target.files[0];\r\n  if (file.type.startsWith('image/')) {\r\n    img.src = URL.createObjectURL(file);\r\n    imageViewerFileSaveBtn.disabled = false;\r\n    imageViewerInitialImage.remove();\r\n  } else {\r\n    if (document.documentElement.lang == \"fr\") {\r\n      imageViewerFileChoiceTxt.innerHTML = '\\u26A0' + ' Ne correspond pas à une image.';\r\n    } else {\r\n      imageViewerFileChoiceTxt.innerHTML = '\\u26A0' + ' Does not correspond to an image.';\r\n    }\r\n  }\r\n};\r\n\r\nimageViewerFileSaveBtn.addEventListener('click', function() {\r\n  var imgsrc = canvas.toDataURL(\"image/png\");\r\n  var blob = dataURLtoBlob(imgsrc);\r\n  var file = new File([blob], 'my_avatar.png', {\r\n    type: \"image/png\",\r\n    lastModified: new Date()\r\n  });\r\n  // console.log(file.size);\r\n  // send image file to server with fetch\r\n  csrf_token = $('input[name=\"csrfmiddlewaretoken\"]').val();\r\n  let formData = new FormData();\r\n  formData.append('file', file);\r\n  formData.append(\"csrfmiddlewaretoken\", csrf_token);\r\n  fetch(imageSaveUri, {\r\n      method: 'POST',\r\n      body: formData,\r\n    }).then(response => response.json())\r\n    .then(response => {\r\n      console.log(response)\r\n    })\r\n});\r\n\r\n// to transform a dataURL to a blob (no need to understand in detail)\r\nfunction dataURLtoBlob(dataurl) {\r\n  var arr = dataurl.split(','),\r\n    mime = arr[0].match(/:(.*?);/)[1],\r\n    bstr = atob(arr[1]),\r\n    n = bstr.length,\r\n    u8arr = new Uint8Array(n);\r\n  while (n--) {\r\n    u8arr[n] = bstr.charCodeAt(n);\r\n  }\r\n  return new Blob([u8arr], {\r\n    type: mime\r\n  });\r\n}\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n//\r\n/////////////////////////////////////////////////////////////////////////////////\n\n//# sourceURL=webpack://zap/../cjs/images.js?");

/***/ }),

/***/ "../cjs/search.js":
/*!************************!*\
  !*** ../cjs/search.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wsiToSearchMessageReceived: () => (/* binding */ wsiToSearchMessageReceived),\n/* harmony export */   wsiToSearchSendQuery: () => (/* binding */ wsiToSearchSendQuery)\n/* harmony export */ });\n/* harmony import */ var _wsi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wsi.js */ \"../cjs/wsi.js\");\n\r\n\r\n\r\n\r\nfunction wsiToSearchSendQuery() { searchToWsiSendQuery(); };\r\nfunction wsiToSearchMessageReceived(message) { showSearchResults(message) };\r\n\r\nconst pageLanguage = document.documentElement.lang;\r\n\r\n\r\nvar screenWidthLg = 992; // Replace with your value\r\n\r\nconst navSearchTriggerBtn = document.getElementsByClassName('btn_nav__search')[0];\r\nconst navSearchMain = document.getElementsByClassName('navSearchMain')[0];\r\n// Fill the div with HTML code\r\nlet navSearchPlaceHolder;\r\nif (pageLanguage == \"fr\") {\r\n  navSearchPlaceHolder = \"Rechercher\";\r\n} else {\r\n  navSearchPlaceHolder = \"Search\";\r\n}\r\nnavSearchMain.innerHTML = `\r\n  <div class=\"d-flex flex-column align-items-center text_color\">\r\n    <div class=\"navSearchBoxDiv0\">\r\n      <div class=\"d-flex d-sm-none navSearchBtnBack navSearchBtnRound\" type=\"button\">\r\n        <svg width=\"30\" height=\"30\">\r\n          <use href=\"/static/images/icons/arrowb.svg#img\"></use>\r\n        </svg>\r\n      </div>\r\n      <div class=\"navSearchBoxDiv1\">\r\n        <div class=\" navSearchBoxDiv2\">\r\n          <input class=\"navSearchInputTxt\" type=\"text\" placeholder=\"${navSearchPlaceHolder}\" maxlength=\"50\"/>\r\n        </div>\r\n        <div class=\"navSearchBtnEnter\" type=\"button\">\r\n          <svg width=\"18\" height=\"18\">\r\n            <use href=\"/static/images/icons/search.svg#img\"></use>\r\n          </svg>\r\n        </div>\r\n        <svg class=\"navSearchIconLoupe\" width=\"14\" height=\"14\">\r\n          <use href=\"/static/images/icons/search.svg#img\"></use>\r\n        </svg>\r\n        <div class=\"navSearchBtnClearX navSearchBtnRound\" type=\"button\">\r\n          <svg width=\"20\" height=\"20\">\r\n            <use href=\"/static/images/icons/x-lg.svg#img\"></use>\r\n          </svg>\r\n        </div>\r\n      </div>\r\n    </div>\r\n    <div class=\"navSearchResDiv0\">\r\n    </div>\r\n  </div>\r\n`;\r\n\r\n// For each one, get a second level of elements by class name within the iteration\r\nconst navSearchInputTxt = navSearchMain.getElementsByClassName('navSearchInputTxt')[0];\r\nconst navSearchIconLoupe = navSearchMain.getElementsByClassName('navSearchIconLoupe')[0];\r\nconst navSearchBtnClearX = navSearchMain.getElementsByClassName('navSearchBtnClearX')[0];\r\nconst navSearchBtnEnter = navSearchMain.getElementsByClassName('navSearchBtnEnter')[0];\r\nconst navSearchBtnBack = navSearchMain.getElementsByClassName('navSearchBtnBack')[0];\r\nconst navSearchBoxDiv0 = navSearchMain.getElementsByClassName('navSearchBoxDiv0')[0];\r\nconst navSearchBoxDiv2 = navSearchMain.getElementsByClassName('navSearchBoxDiv2')[0];\r\nconst navSearchResDiv0 = navSearchMain.getElementsByClassName('navSearchResDiv0')[0];\r\n\r\nfunction showSearchControl() {\r\n  navSearchIconLoupe.style.display = \"block\";\r\n  navSearchBoxDiv2.style.marginLeft = '0';\r\n  navSearchBoxDiv2.style.paddingLeft = '25px';\r\n  navSearchBoxDiv2.style.border = '1px solid var(--color-searchborderselect)';\r\n  navSearchResDiv0.style.display = 'block';\r\n  if (!window.matchMedia('(min-width: ' + screenWidthLg + 'px)').matches) {\r\n    navSearchMain.style.display = \"block\";\r\n  }\r\n  navSearchInputTxt.focus();\r\n  navSearchTriggerBtn.setAttribute('aria-expanded', 'true');\r\n  // hide the main page scroll bar under a certain screen width\r\n  if (window.innerWidth < 620) {\r\n    document.body.style.overflowY = 'hidden';\r\n  }\r\n  (0,_wsi_js__WEBPACK_IMPORTED_MODULE_0__.wsiOpenSharedSocket)();\r\n  sendWSnavSearchMessage();\r\n}\r\n\r\nfunction hideSearchControl() {\r\n  navSearchIconLoupe.style.display = \"none\";\r\n  navSearchBoxDiv2.style.marginLeft = '25px';\r\n  navSearchBoxDiv2.style.paddingLeft = '0';\r\n  navSearchBoxDiv2.style.border = '1px solid var(--color-searchbutton)';\r\n  navSearchResDiv0.style.display = 'none';\r\n  if (!window.matchMedia('(min-width: ' + screenWidthLg + 'px)').matches) {\r\n    navSearchMain.style.display = \"none\";\r\n  }\r\n  navSearchInputTxt.blur();\r\n  navSearchTriggerBtn.setAttribute('aria-expanded', 'false');\r\n  document.body.style.overflowY = 'auto';\r\n}\r\n\r\nvar activatedSearchResults = false;\r\n\r\nfunction activateSearchBox() {\r\n  activatedSearchResults = true;\r\n  showSearchControl();\r\n\r\n  // Unhide navSearchBtnClearX if there is text inside the input field\r\n  if (navSearchInputTxt.value !== \"\") {\r\n    navSearchBtnClearX.style.display = \"flex\";\r\n  }\r\n\r\n  function deactivateSearchBox() {\r\n    activatedSearchResults = false;\r\n    navSearchInputTxt.removeEventListener('input', handleInputTextChange);\r\n    navSearchBtnClearX.removeEventListener('mousedown', handlePreventXbuttonFocusLoss);\r\n    navSearchBtnClearX.removeEventListener('mouseup', handleClickOnXbutton);\r\n    navSearchMain.removeEventListener('mousedown', handlePreventLeavingInput);\r\n    navSearchMain.removeEventListener('wheel', handleScrollingFromMainCtn);\r\n    document.removeEventListener('mousedown', handleClickedOutside);\r\n    document.removeEventListener('keydown', handleEscapeKeydown);\r\n    navSearchBtnBack.removeEventListener('click', handleBackButtonClick);\r\n    navSearchTriggerBtn.removeEventListener('click', handleSearchTriggerBtnClick);\r\n    hideSearchControl();\r\n  }\r\n\r\n  function handleInputTextChange(event) {\r\n    // Unhide navSearchBtnClearX if there is text inside the input field\r\n    if (this.value !== \"\") {\r\n      navSearchBtnClearX.style.display = \"flex\";\r\n    } else {\r\n      // Hide navSearchBtnClearX if the input field is empty\r\n      navSearchBtnClearX.style.display = \"none\";\r\n    }\r\n    sendWSnavSearchMessage()\r\n  }\r\n  navSearchInputTxt.addEventListener('input', handleInputTextChange);\r\n\r\n  function handlePreventXbuttonFocusLoss(event) {\r\n    event.preventDefault();\r\n    event.stopPropagation();\r\n  }\r\n  navSearchBtnClearX.addEventListener('mousedown', handlePreventXbuttonFocusLoss);\r\n\r\n  function handleClickOnXbutton(event) {\r\n    navSearchInputTxt.value = \"\";\r\n    navSearchInputTxt.focus();\r\n    navSearchBtnClearX.style.display = \"none\";\r\n    sendWSnavSearchMessage()\r\n  }\r\n  navSearchBtnClearX.addEventListener('mouseup', handleClickOnXbutton);\r\n\r\n  function handlePreventLeavingInput(event) {\r\n    if (event.target !== navSearchInputTxt) {\r\n      event.preventDefault();\r\n    }\r\n  }\r\n  navSearchMain.addEventListener('mousedown', handlePreventLeavingInput);\r\n\r\n  function handleScrollingFromMainCtn(event) {\r\n    var delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail)));\r\n    navSearchResDiv0.scrollTop -= (delta * 30);\r\n    event.preventDefault();\r\n  }\r\n  navSearchMain.addEventListener('wheel', handleScrollingFromMainCtn);\r\n\r\n  function handleClickedOutside(event) {\r\n    let clickedOnScrollbar = document.documentElement.clientWidth <= event.clientX;\r\n    if (!clickedOnScrollbar &&\r\n      !navSearchMain.contains(event.target) &&\r\n      !navSearchResDiv0.contains(event.target) &&\r\n      !navSearchTriggerBtn.contains(event.target)) {\r\n      // The click occurred outside of both elements\r\n      deactivateSearchBox();\r\n    }\r\n  }\r\n  document.addEventListener('mousedown', handleClickedOutside);\r\n\r\n  function handleEscapeKeydown(event) {\r\n    if (event.key === 'Escape') {\r\n      deactivateSearchBox();\r\n    }\r\n  }\r\n  document.addEventListener('keydown', handleEscapeKeydown);\r\n\r\n  function handleBackButtonClick(event) {\r\n    deactivateSearchBox();\r\n  }\r\n  navSearchBtnBack.addEventListener(\"click\", handleBackButtonClick);\r\n\r\n  function handleSearchTriggerBtnClick(event) {\r\n    if (navSearchTriggerBtn.getAttribute('aria-expanded') === 'true') {\r\n      deactivateSearchBox();\r\n    }\r\n  }\r\n  navSearchTriggerBtn.addEventListener(\"click\", handleSearchTriggerBtnClick);\r\n\r\n}\r\n\r\nnavSearchInputTxt.addEventListener(\"mousedown\", function() {\r\n  if (!activatedSearchResults) {\r\n    activateSearchBox();\r\n  }\r\n});\r\n\r\nnavSearchBtnEnter.addEventListener(\"click\", function() {\r\n  console.log(\"search button click\")\r\n});\r\n\r\nnavSearchTriggerBtn.addEventListener('click', function() {\r\n  if (navSearchTriggerBtn.getAttribute('aria-expanded') === 'false') {\r\n    if (!activatedSearchResults) {\r\n      activateSearchBox();\r\n    }\r\n  }\r\n});\r\n\r\n// Change the display based on windows width\r\nfunction setSearchBoxDisplayPerScreenWidth() {\r\n  if (window.matchMedia('(min-width: ' + screenWidthLg + 'px)').matches) {\r\n    navSearchMain.style.display = \"block\";\r\n  } else {\r\n    if (navSearchMain.style.display == \"block\" &&\r\n      navSearchResDiv0.style.display == \"none\") {\r\n      navSearchMain.style.display = \"none\";\r\n    }\r\n  }\r\n}\r\nnavSearchMain.style.display = \"none\";\r\nnavSearchResDiv0.style.display = \"none\";\r\nsetSearchBoxDisplayPerScreenWidth()\r\n\r\nwindow.addEventListener('resize', function() {\r\n  setSearchBoxDisplayPerScreenWidth();\r\n});\r\n\r\n\r\n\r\n\r\n\r\n// /////////////////////////////////////////////////////////////////////////////////\r\n// //  Nav Search websocket\r\n// /////////////////////////////////////////////////////////////////////////////////\r\nvar navSearchStartTimer;\r\n\r\nfunction showSearchResults(jsonObject) {\r\n  navSearchStartTimer = performance.now();\r\n  var jsonArray = JSON.parse(jsonObject);\r\n  var ul = document.createElement(\"ul\");\r\n  for (var i = 0; i < jsonArray.length; i++) {\r\n    // Create a list item element\r\n    var li = document.createElement(\"li\");\r\n    // Set the content of the list item to the name and age of each person\r\n    li.innerHTML = jsonArray[i].title + \" (\" + jsonArray[i].vote + \")\";\r\n    // Append the list item to the list\r\n    ul.appendChild(li);\r\n  }\r\n  navSearchResDiv0.innerHTML = \"\";\r\n  navSearchResDiv0.appendChild(ul);\r\n\r\n  let timeDiff = performance.now() - navSearchStartTimer;\r\n  console.log(`${timeDiff} ms.`);\r\n}\r\n\r\nfunction searchToWsiSendQuery() {\r\n  navSearchStartTimer = performance.now();\r\n  (0,_wsi_js__WEBPACK_IMPORTED_MODULE_0__.wsiSend)('s' + _wsi_js__WEBPACK_IMPORTED_MODULE_0__.wsiCurrentTabId + navSearchInputTxt.value);\r\n}\r\n\r\nconst sendWSnavSearchMessage = debounce_search(searchToWsiSendQuery, 400);\r\n\r\nfunction debounce_search(func, delay) {\r\n  let lastCallTime = 0;\r\n  let timeoutId;\r\n\r\n  return function() {\r\n    const context = this;\r\n    const args = arguments;\r\n    const now = Date.now();\r\n\r\n    clearTimeout(timeoutId);\r\n\r\n    if (now - lastCallTime < delay) {\r\n      timeoutId = setTimeout(() => {\r\n        lastCallTime = Date.now();\r\n        func.apply(context, args);\r\n      }, delay - (now - lastCallTime));\r\n    } else {\r\n      lastCallTime = now;\r\n      func.apply(context, args);\r\n    }\r\n  }\r\n}\n\n//# sourceURL=webpack://zap/../cjs/search.js?");

/***/ }),

/***/ "../cjs/wsi.js":
/*!*********************!*\
  !*** ../cjs/wsi.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wsiCurrentTabId: () => (/* binding */ wsiCurrentTabId),\n/* harmony export */   wsiOpenSharedSocket: () => (/* binding */ wsiOpenSharedSocket),\n/* harmony export */   wsiReconnect: () => (/* binding */ wsiReconnect),\n/* harmony export */   wsiSend: () => (/* binding */ wsiSend)\n/* harmony export */ });\n/* harmony import */ var _search_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./search.js */ \"../cjs/search.js\");\n/////////////////////////////////////////////////////////////////////////////////\r\n//    Dynamic imports\r\n//    do the imports in js instead of normal imports in case the module\r\n//    is not present since search or filespro may not be required\r\n/////////////////////////////////////////////////////////////////////////////////\r\nlet wsiToFilesproAskForListOfFiles, wsiToFilesproMessageReceived;\r\n\r\nimport ( /* webpackIgnore: true */ './filescript.js')\r\n.then((module) => {\r\n    wsiToFilesproAskForListOfFiles = module.wsiToFilesproAskForListOfFiles;\r\n    wsiToFilesproMessageReceived = module.wsiToFilesproMessageReceived;\r\n  })\r\n  .catch((error) => {});\r\n\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n//    wsi\r\n/////////////////////////////////////////////////////////////////////////////////\r\n// localStorage of the browser is used to store the last tabId in a single char\r\n// get the next wsiCurrentTabId in storage, single character\r\nvar wsiCurrentTabId = localStorage.getItem('wsiCurrentTabId');\r\nif (wsiCurrentTabId !== null) {\r\n  var nextTabId = wsiCurrentTabId.charCodeAt(0) + 1;\r\n  //   33; // '!' to  126; // '~'\r\n  if (nextTabId > 126) {\r\n    nextTabId = 33;\r\n  }\r\n  localStorage.setItem('wsiCurrentTabId', String.fromCharCode(nextTabId));\r\n} else {\r\n  wsiCurrentTabId = String.fromCharCode(33);\r\n  localStorage.setItem('wsiCurrentTabId', wsiCurrentTabId);\r\n}\r\n\r\nfunction handleWsEvent(event) {\r\n  switch (event.type) {\r\n    case 'onopen':\r\n      console.log('WebSocket is open');\r\n      // check if the module is loaded\r\n      if (typeof _search_js__WEBPACK_IMPORTED_MODULE_0__.wsiToSearchSendQuery === 'function') {\r\n        (0,_search_js__WEBPACK_IMPORTED_MODULE_0__.wsiToSearchSendQuery)();\r\n      }\r\n      if (typeof wsiToFilesproAskForListOfFiles === 'function') {\r\n        wsiToFilesproAskForListOfFiles();\r\n      }\r\n      break;\r\n    case 'onclose':\r\n      console.log('WebSocket is closed');\r\n      break;\r\n    case 'onerror':\r\n      console.log('WebSocket encountered an error');\r\n      break;\r\n    case 'onmessage':\r\n      console.log('Received message:', event.data);\r\n      if (event.data.length > 2) {\r\n        let message = event.data.substring(2)\r\n        if (event.data[1] == wsiCurrentTabId) {\r\n          switch (event.data[0]) {\r\n            case 's':\r\n              // check if the module is loaded\r\n              if (typeof _search_js__WEBPACK_IMPORTED_MODULE_0__.wsiToSearchMessageReceived === 'function') {\r\n                (0,_search_js__WEBPACK_IMPORTED_MODULE_0__.wsiToSearchMessageReceived)(message);\r\n              }\r\n            case 'f':\r\n              if (typeof wsiToFilesproMessageReceived === 'function') {\r\n                wsiToFilesproMessageReceived(message);\r\n              }\r\n          }\r\n        }\r\n      }\r\n      break;\r\n    default:\r\n  }\r\n}\r\n\r\nconst websocketUrl = (window.location.protocol === 'https:' ? 'wss://' : 'ws://') +\r\n  window.location.host + '/wsi/';\r\nlet wsworker;\r\nlet gsocket;\r\nlet useSharedWorker = !!window.SharedWorker; // is supported\r\n\r\nfunction wsiOpenSharedSocket() {\r\n  if (typeof wsworker === 'undefined') {\r\n    if (useSharedWorker) {\r\n      wsworker = new SharedWorker('/static/js/sharedWorker.js');\r\n\r\n      wsworker.port.onmessage = function(e) {\r\n        handleWsEvent(e.data);\r\n      };\r\n\r\n      wsworker.port.start();\r\n\r\n      wsworker.port.postMessage({\r\n        command: 'connect',\r\n        url: websocketUrl\r\n      });\r\n    } else {\r\n      initiateWebsocketFallback();\r\n    }\r\n    window.addEventListener('beforeunload', function() {\r\n      if (useSharedWorker) {\r\n        wsworker.port.postMessage({\r\n          command: 'removePort'\r\n        });\r\n      } else {\r\n        gsocket.close()\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction initiateWebsocketFallback() {\r\n  gsocket = new WebSocket(websocketUrl);\r\n\r\n  gsocket.onopen = function() {\r\n    handleWsEvent({\r\n      type: 'onopen'\r\n    });\r\n  };\r\n\r\n  gsocket.onmessage = function(e) {\r\n    handleWsEvent({\r\n      type: 'onmessage',\r\n      data: e.data\r\n    });\r\n  };\r\n\r\n  gsocket.onerror = function() {\r\n    handleWsEvent({\r\n      type: 'onerror'\r\n    });\r\n  };\r\n\r\n  gsocket.onclose = function() {\r\n    handleWsEvent({\r\n      type: 'onclose'\r\n    });\r\n  };\r\n}\r\n\r\nfunction wsiSend(message) {\r\n  if (useSharedWorker) {\r\n    wsworker.port.postMessage({\r\n      command: 'send',\r\n      message: message\r\n    });\r\n  } else if (gsocket && gsocket.readyState === WebSocket.OPEN) {\r\n    gsocket.send(message);\r\n  }\r\n}\r\n\r\nfunction wsiReconnect() {\r\n  if (useSharedWorker) {\r\n    wsworker.port.postMessage({\r\n      command: 'reconnect',\r\n      url: websocketUrl\r\n    });\r\n  } else if (gsocket && gsocket.readyState === WebSocket.OPEN) {\r\n    gsocket.close();\r\n    gsocket = null;\r\n    initiateWebsocketFallback();\r\n  }\r\n}\n\n//# sourceURL=webpack://zap/../cjs/wsi.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	__webpack_require__("../cjs/filespro.js");
/******/ 	var __webpack_exports__ = __webpack_require__("../cjs/images.js");
/******/ 	
/******/ })()
;